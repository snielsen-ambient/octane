"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.swapQuoteWithParams = exports.swapQuoteByOutputToken = exports.swapQuoteByInputToken = void 0;
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const pool_utils_1 = require("../../utils/public/pool-utils");
const common_sdk_1 = require("@orca-so/common-sdk");
const public_1 = require("../../utils/public");
const swap_quote_impl_1 = require("../swap/swap-quote-impl");
const swap_utils_1 = require("../../utils/public/swap-utils");
/**
 * Get an estimated swap quote using input token amount.
 *
 * @category Quotes
 * @param whirlpool - Whirlpool to perform the swap on
 * @param inputTokenMint - PublicKey for the input token mint to swap with
 * @param tokenAmount - The amount of input token to swap from
 * @param slippageTolerance - The amount of slippage to account for in this quote
 * @param programId - PublicKey for the Whirlpool ProgramId
 * @param fetcher - AccountFetcher object to fetch solana accounts
 * @param refresh - If true, fetcher would default to fetching the latest accounts
 * @returns a SwapQuote object with slippage adjusted SwapInput parameters & estimates on token amounts, fee & end whirlpool states.
 */
function swapQuoteByInputToken(whirlpool, inputTokenMint, tokenAmount, slippageTolerance, programId, fetcher, refresh) {
    return __awaiter(this, void 0, void 0, function* () {
        return swapQuoteByToken(whirlpool, inputTokenMint, tokenAmount, slippageTolerance, public_1.TokenType.TokenA, true, programId, fetcher, refresh);
    });
}
exports.swapQuoteByInputToken = swapQuoteByInputToken;
/**
 * Get an estimated swap quote using an output token amount.
 *
 * Use this quote to get an estimated amount of input token needed to receive
 * the defined output token amount.
 *
 * @category Quotes
 * @param whirlpool - Whirlpool to perform the swap on
 * @param outputTokenMint - PublicKey for the output token mint to swap into
 * @param tokenAmount - The maximum amount of output token to receive in this swap.
 * @param slippageTolerance - The amount of slippage to account for in this quote
 * @param programId - PublicKey for the Whirlpool ProgramId
 * @param fetcher - AccountFetcher object to fetch solana accounts
 * @param refresh - If true, fetcher would default to fetching the latest accounts
 * @returns a SwapQuote object with slippage adjusted SwapInput parameters & estimates on token amounts, fee & end whirlpool states.
 */
function swapQuoteByOutputToken(whirlpool, outputTokenMint, tokenAmount, slippageTolerance, programId, fetcher, refresh) {
    return __awaiter(this, void 0, void 0, function* () {
        return swapQuoteByToken(whirlpool, outputTokenMint, tokenAmount, slippageTolerance, public_1.TokenType.TokenB, false, programId, fetcher, refresh);
    });
}
exports.swapQuoteByOutputToken = swapQuoteByOutputToken;
/**
 * Perform a sync swap quote based on the basic swap instruction parameters.
 *
 * @category Quotes
 * @param params - SwapQuote parameters
 * @param slippageTolerance - The amount of slippage to account for when generating the final quote.
 * @returns a SwapQuote object with slippage adjusted SwapInput parameters & estimates on token amounts, fee & end whirlpool states.
 */
function swapQuoteWithParams(params, slippageTolerance) {
    checkIfAllTickArraysInitialized(params.tickArrays);
    const quote = (0, swap_quote_impl_1.simulateSwap)(params);
    const slippageAdjustedQuote = Object.assign(Object.assign({}, quote), swap_utils_1.SwapUtils.calculateSwapAmountsFromQuote(params.tokenAmount, quote.estimatedAmountIn, quote.estimatedAmountOut, slippageTolerance, params.amountSpecifiedIsInput));
    return slippageAdjustedQuote;
}
exports.swapQuoteWithParams = swapQuoteWithParams;
function swapQuoteByToken(whirlpool, inputTokenMint, tokenAmount, slippageTolerance, amountSpecifiedTokenType, amountSpecifiedIsInput, programId, fetcher, refresh) {
    return __awaiter(this, void 0, void 0, function* () {
        const whirlpoolData = whirlpool.getData();
        const swapMintKey = common_sdk_1.AddressUtil.toPubKey(inputTokenMint);
        const swapTokenType = pool_utils_1.PoolUtil.getTokenType(whirlpoolData, swapMintKey);
        (0, tiny_invariant_1.default)(!!swapTokenType, "swapTokenMint does not match any tokens on this pool");
        const aToB = swapTokenType === amountSpecifiedTokenType;
        const tickArrays = yield swap_utils_1.SwapUtils.getTickArrays(whirlpoolData.tickCurrentIndex, whirlpoolData.tickSpacing, aToB, common_sdk_1.AddressUtil.toPubKey(programId), whirlpool.getAddress(), fetcher, refresh);
        return swapQuoteWithParams({
            whirlpoolData,
            tokenAmount,
            aToB,
            amountSpecifiedIsInput,
            sqrtPriceLimit: swap_utils_1.SwapUtils.getDefaultSqrtPriceLimit(aToB),
            otherAmountThreshold: swap_utils_1.SwapUtils.getDefaultOtherAmountThreshold(amountSpecifiedIsInput),
            tickArrays,
        }, slippageTolerance);
    });
}
function checkIfAllTickArraysInitialized(tickArrays) {
    // Check if all the tick arrays have been initialized.
    const uninitializedIndices = public_1.TickArrayUtil.getUninitializedArrays(tickArrays.map((array) => array.data));
    if (uninitializedIndices.length > 0) {
        const uninitializedArrays = uninitializedIndices
            .map((index) => tickArrays[index].address.toBase58())
            .join(", ");
        throw new Error(`TickArray addresses - [${uninitializedArrays}] need to be initialized.`);
    }
}
