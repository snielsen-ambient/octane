"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhirlpoolClientImpl = void 0;
const common_sdk_1 = require("@orca-so/common-sdk");
const public_1 = require("../utils/public");
const position_impl_1 = require("./position-impl");
const util_1 = require("./util");
const whirlpool_impl_1 = require("./whirlpool-impl");
class WhirlpoolClientImpl {
    constructor(ctx) {
        this.ctx = ctx;
    }
    getContext() {
        return this.ctx;
    }
    getFetcher() {
        return this.ctx.fetcher;
    }
    getPool(poolAddress, refresh = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.ctx.fetcher.getPool(poolAddress, refresh);
            if (!account) {
                throw new Error(`Unable to fetch Whirlpool at address at ${poolAddress}`);
            }
            const tokenInfos = yield (0, util_1.getTokenMintInfos)(this.ctx.fetcher, account, refresh);
            const vaultInfos = yield (0, util_1.getTokenVaultAccountInfos)(this.ctx.fetcher, account, refresh);
            const rewardInfos = yield (0, util_1.getRewardInfos)(this.ctx.fetcher, account, refresh);
            return new whirlpool_impl_1.WhirlpoolImpl(this.ctx, this.ctx.fetcher, common_sdk_1.AddressUtil.toPubKey(poolAddress), tokenInfos[0], tokenInfos[1], vaultInfos[0], vaultInfos[1], rewardInfos, account);
        });
    }
    getPools(poolAddresses, refresh = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = (yield this.ctx.fetcher.listPools(poolAddresses, refresh)).filter((account) => !!account);
            if (accounts.length !== poolAddresses.length) {
                throw new Error(`Unable to fetch all Whirlpools at addresses ${poolAddresses}`);
            }
            const tokenMints = new Set();
            const tokenAccounts = new Set();
            accounts.forEach((account) => {
                tokenMints.add(account.tokenMintA.toBase58());
                tokenMints.add(account.tokenMintB.toBase58());
                tokenAccounts.add(account.tokenVaultA.toBase58());
                tokenAccounts.add(account.tokenVaultB.toBase58());
                account.rewardInfos.forEach((rewardInfo) => {
                    if (public_1.PoolUtil.isRewardInitialized(rewardInfo)) {
                        tokenAccounts.add(rewardInfo.vault.toBase58());
                    }
                });
            });
            yield this.ctx.fetcher.listMintInfos(Array.from(tokenMints), refresh);
            yield this.ctx.fetcher.listTokenInfos(Array.from(tokenAccounts), refresh);
            const whirlpools = [];
            for (let i = 0; i < accounts.length; i++) {
                const account = accounts[i];
                const poolAddress = poolAddresses[i];
                const tokenInfos = yield (0, util_1.getTokenMintInfos)(this.ctx.fetcher, account, false);
                const vaultInfos = yield (0, util_1.getTokenVaultAccountInfos)(this.ctx.fetcher, account, false);
                const rewardInfos = yield (0, util_1.getRewardInfos)(this.ctx.fetcher, account, false);
                whirlpools.push(new whirlpool_impl_1.WhirlpoolImpl(this.ctx, this.ctx.fetcher, common_sdk_1.AddressUtil.toPubKey(poolAddress), tokenInfos[0], tokenInfos[1], vaultInfos[0], vaultInfos[1], rewardInfos, account));
            }
            return whirlpools;
        });
    }
    getPosition(positionAddress, refresh = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.ctx.fetcher.getPosition(positionAddress, refresh);
            if (!account) {
                throw new Error(`Unable to fetch Position at address at ${positionAddress}`);
            }
            return new position_impl_1.PositionImpl(this.ctx, this.ctx.fetcher, common_sdk_1.AddressUtil.toPubKey(positionAddress), account);
        });
    }
}
exports.WhirlpoolClientImpl = WhirlpoolClientImpl;
