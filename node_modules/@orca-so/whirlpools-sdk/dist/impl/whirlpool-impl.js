"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhirlpoolImpl = void 0;
const common_sdk_1 = require("@orca-so/common-sdk");
const anchor_1 = require("@project-serum/anchor");
const instructions_1 = require("../instructions");
const web3_js_1 = require("@solana/web3.js");
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const public_1 = require("../utils/public");
const public_2 = require("../quotes/public");
const util_1 = require("./util");
class WhirlpoolImpl {
    constructor(ctx, fetcher, address, tokenAInfo, tokenBInfo, tokenVaultAInfo, tokenVaultBInfo, rewardInfos, data) {
        this.ctx = ctx;
        this.fetcher = fetcher;
        this.address = address;
        this.tokenAInfo = tokenAInfo;
        this.tokenBInfo = tokenBInfo;
        this.tokenVaultAInfo = tokenVaultAInfo;
        this.tokenVaultBInfo = tokenVaultBInfo;
        this.rewardInfos = rewardInfos;
        this.data = data;
    }
    getAddress() {
        return this.address;
    }
    getData() {
        return this.data;
    }
    getTokenAInfo() {
        return this.tokenAInfo;
    }
    getTokenBInfo() {
        return this.tokenBInfo;
    }
    getTokenVaultAInfo() {
        return this.tokenVaultAInfo;
    }
    getTokenVaultBInfo() {
        return this.tokenVaultBInfo;
    }
    getRewardInfos() {
        return this.rewardInfos;
    }
    refreshData() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.refresh();
            return this.data;
        });
    }
    openPosition(tickLower, tickUpper, liquidityInput, wallet, funder) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.refresh();
            return this.getOpenPositionWithOptMetadataTx(tickLower, tickUpper, liquidityInput, !!wallet ? common_sdk_1.AddressUtil.toPubKey(wallet) : this.ctx.wallet.publicKey, !!funder ? common_sdk_1.AddressUtil.toPubKey(funder) : this.ctx.wallet.publicKey);
        });
    }
    openPositionWithMetadata(tickLower, tickUpper, liquidityInput, sourceWallet, positionWallet, funder) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.refresh();
            return this.getOpenPositionWithOptMetadataTx(tickLower, tickUpper, liquidityInput, !!sourceWallet ? common_sdk_1.AddressUtil.toPubKey(sourceWallet) : this.ctx.wallet.publicKey, !!funder ? common_sdk_1.AddressUtil.toPubKey(funder) : this.ctx.wallet.publicKey, true);
        });
    }
    initTickArrayForTicks(ticks, funder, refresh = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const initTickArrayStartPdas = yield public_1.TickArrayUtil.getUninitializedArraysPDAs(ticks, this.ctx.program.programId, this.address, this.data.tickSpacing, this.fetcher, refresh);
            if (!initTickArrayStartPdas.length) {
                return null;
            }
            const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet);
            initTickArrayStartPdas.forEach((initTickArrayInfo) => {
                txBuilder.addInstruction((0, instructions_1.initTickArrayIx)(this.ctx.program, {
                    startTick: initTickArrayInfo.startIndex,
                    tickArrayPda: initTickArrayInfo.pda,
                    whirlpool: this.address,
                    funder: !!funder ? common_sdk_1.AddressUtil.toPubKey(funder) : this.ctx.provider.wallet.publicKey,
                }));
            });
            return txBuilder;
        });
    }
    closePosition(positionAddress, slippageTolerance, destinationWallet, positionWallet, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.refresh();
            const positionWalletKey = positionWallet
                ? common_sdk_1.AddressUtil.toPubKey(positionWallet)
                : this.ctx.wallet.publicKey;
            const destinationWalletKey = destinationWallet
                ? common_sdk_1.AddressUtil.toPubKey(destinationWallet)
                : this.ctx.wallet.publicKey;
            const payerKey = payer ? common_sdk_1.AddressUtil.toPubKey(payer) : this.ctx.wallet.publicKey;
            return this.getClosePositionIx(common_sdk_1.AddressUtil.toPubKey(positionAddress), slippageTolerance, destinationWalletKey, positionWalletKey, payerKey);
        });
    }
    swap(quote, sourceWallet) {
        return __awaiter(this, void 0, void 0, function* () {
            const sourceWalletKey = sourceWallet
                ? common_sdk_1.AddressUtil.toPubKey(sourceWallet)
                : this.ctx.wallet.publicKey;
            return this.getSwapTx(quote, sourceWalletKey);
        });
    }
    /**
     * Construct a transaction for opening an new position with optional metadata
     */
    getOpenPositionWithOptMetadataTx(tickLower, tickUpper, liquidityInput, wallet, funder, withMetadata = false) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(tickLower), "tickLower is out of bounds.");
            (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(tickUpper), "tickUpper is out of bounds.");
            const { liquidityAmount: liquidity, tokenMaxA, tokenMaxB } = liquidityInput;
            (0, tiny_invariant_1.default)(liquidity.gt(new anchor_1.BN(0)), "liquidity must be greater than zero");
            const whirlpool = yield this.fetcher.getPool(this.address, false);
            if (!whirlpool) {
                throw new Error(`Whirlpool not found: ${(0, anchor_1.translateAddress)(this.address).toBase58()}`);
            }
            (0, tiny_invariant_1.default)(public_1.TickUtil.isTickInitializable(tickLower, whirlpool.tickSpacing), `lower tick ${tickLower} is not an initializable tick for tick-spacing ${whirlpool.tickSpacing}`);
            (0, tiny_invariant_1.default)(public_1.TickUtil.isTickInitializable(tickUpper, whirlpool.tickSpacing), `upper tick ${tickUpper} is not an initializable tick for tick-spacing ${whirlpool.tickSpacing}`);
            const positionMintKeypair = web3_js_1.Keypair.generate();
            const positionPda = public_1.PDAUtil.getPosition(this.ctx.program.programId, positionMintKeypair.publicKey);
            const metadataPda = public_1.PDAUtil.getPositionMetadata(positionMintKeypair.publicKey);
            const positionTokenAccountAddress = yield (0, common_sdk_1.deriveATA)(wallet, positionMintKeypair.publicKey);
            const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet);
            const positionIx = (withMetadata ? instructions_1.openPositionWithMetadataIx : instructions_1.openPositionIx)(this.ctx.program, {
                funder,
                owner: wallet,
                positionPda,
                metadataPda,
                positionMintAddress: positionMintKeypair.publicKey,
                positionTokenAccount: positionTokenAccountAddress,
                whirlpool: this.address,
                tickLowerIndex: tickLower,
                tickUpperIndex: tickUpper,
            });
            txBuilder.addInstruction(positionIx).addSigner(positionMintKeypair);
            const [ataA, ataB] = yield (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, wallet, [
                { tokenMint: whirlpool.tokenMintA, wrappedSolAmountIn: tokenMaxA },
                { tokenMint: whirlpool.tokenMintB, wrappedSolAmountIn: tokenMaxB },
            ], () => this.fetcher.getAccountRentExempt(), funder);
            const { address: tokenOwnerAccountA } = ataA, tokenOwnerAccountAIx = __rest(ataA, ["address"]);
            const { address: tokenOwnerAccountB } = ataB, tokenOwnerAccountBIx = __rest(ataB, ["address"]);
            txBuilder.addInstruction(tokenOwnerAccountAIx);
            txBuilder.addInstruction(tokenOwnerAccountBIx);
            const tickArrayLowerPda = public_1.PDAUtil.getTickArrayFromTickIndex(tickLower, this.data.tickSpacing, this.address, this.ctx.program.programId);
            const tickArrayUpperPda = public_1.PDAUtil.getTickArrayFromTickIndex(tickUpper, this.data.tickSpacing, this.address, this.ctx.program.programId);
            const liquidityIx = (0, instructions_1.increaseLiquidityIx)(this.ctx.program, {
                liquidityAmount: liquidity,
                tokenMaxA,
                tokenMaxB,
                whirlpool: this.address,
                positionAuthority: wallet,
                position: positionPda.publicKey,
                positionTokenAccount: positionTokenAccountAddress,
                tokenOwnerAccountA,
                tokenOwnerAccountB,
                tokenVaultA: whirlpool.tokenVaultA,
                tokenVaultB: whirlpool.tokenVaultB,
                tickArrayLower: tickArrayLowerPda.publicKey,
                tickArrayUpper: tickArrayUpperPda.publicKey,
            });
            txBuilder.addInstruction(liquidityIx);
            return {
                positionMint: positionMintKeypair.publicKey,
                tx: txBuilder,
            };
        });
    }
    getClosePositionIx(positionAddress, slippageTolerance, destinationWallet, positionWallet, payerKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const position = yield this.fetcher.getPosition(positionAddress, true);
            if (!position) {
                throw new Error(`Position not found: ${positionAddress.toBase58()}`);
            }
            const whirlpool = this.data;
            (0, tiny_invariant_1.default)(position.whirlpool.equals(this.address), `Position ${positionAddress.toBase58()} is not a position for Whirlpool ${this.address.toBase58()}`);
            const tickArrayLower = public_1.PDAUtil.getTickArrayFromTickIndex(position.tickLowerIndex, whirlpool.tickSpacing, position.whirlpool, this.ctx.program.programId).publicKey;
            const tickArrayUpper = public_1.PDAUtil.getTickArrayFromTickIndex(position.tickUpperIndex, whirlpool.tickSpacing, position.whirlpool, this.ctx.program.programId).publicKey;
            const positionTokenAccount = yield (0, common_sdk_1.deriveATA)(positionWallet, position.positionMint);
            const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet);
            const resolvedAssociatedTokenAddresses = {};
            const [ataA, ataB] = yield (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, destinationWallet, [{ tokenMint: whirlpool.tokenMintA }, { tokenMint: whirlpool.tokenMintB }], () => this.fetcher.getAccountRentExempt(), payerKey);
            const { address: tokenOwnerAccountA } = ataA, createTokenOwnerAccountAIx = __rest(ataA, ["address"]);
            const { address: tokenOwnerAccountB } = ataB, createTokenOwnerAccountBIx = __rest(ataB, ["address"]);
            txBuilder.addInstruction(createTokenOwnerAccountAIx).addInstruction(createTokenOwnerAccountBIx);
            resolvedAssociatedTokenAddresses[whirlpool.tokenMintA.toBase58()] = tokenOwnerAccountA;
            resolvedAssociatedTokenAddresses[whirlpool.tokenMintB.toBase58()] = tokenOwnerAccountB;
            // TODO: Collect all Fees and rewards for the position.
            // TODO: Optimize - no need to call updateFee if we call decreaseLiquidity first.
            // const collectTx = await buildCollectFeesAndRewardsTx(this.dal, {
            //   provider,
            //   positionAddress: positionAddress,
            //   resolvedAssociatedTokenAddresses,
            // });
            // txBuilder.addInstruction(collectTx.compressIx(false));
            /* Remove all liquidity remaining in the position */
            if (position.liquidity.gt(new anchor_1.BN(0))) {
                const decreaseLiqQuote = (0, public_2.decreaseLiquidityQuoteByLiquidityWithParams)({
                    liquidity: position.liquidity,
                    slippageTolerance,
                    sqrtPrice: whirlpool.sqrtPrice,
                    tickCurrentIndex: whirlpool.tickCurrentIndex,
                    tickLowerIndex: position.tickLowerIndex,
                    tickUpperIndex: position.tickUpperIndex,
                });
                const liquidityIx = (0, instructions_1.decreaseLiquidityIx)(this.ctx.program, {
                    liquidityAmount: decreaseLiqQuote.liquidityAmount,
                    tokenMinA: decreaseLiqQuote.tokenMinA,
                    tokenMinB: decreaseLiqQuote.tokenMinB,
                    whirlpool: position.whirlpool,
                    positionAuthority: positionWallet,
                    position: positionAddress,
                    positionTokenAccount,
                    tokenOwnerAccountA,
                    tokenOwnerAccountB,
                    tokenVaultA: whirlpool.tokenVaultA,
                    tokenVaultB: whirlpool.tokenVaultB,
                    tickArrayLower,
                    tickArrayUpper,
                });
                txBuilder.addInstruction(liquidityIx);
            }
            /* Close position */
            const positionIx = (0, instructions_1.closePositionIx)(this.ctx.program, {
                positionAuthority: positionWallet,
                receiver: destinationWallet,
                positionTokenAccount,
                position: positionAddress,
                positionMint: position.positionMint,
            });
            txBuilder.addInstruction(positionIx);
            return txBuilder;
        });
    }
    getSwapTx(input, wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            const { amount, aToB } = input;
            const whirlpool = this.data;
            const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet);
            const [ataA, ataB] = yield (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, wallet, [
                { tokenMint: whirlpool.tokenMintA, wrappedSolAmountIn: aToB ? amount : common_sdk_1.ZERO },
                { tokenMint: whirlpool.tokenMintB, wrappedSolAmountIn: !aToB ? amount : common_sdk_1.ZERO },
            ], () => this.fetcher.getAccountRentExempt());
            const { address: tokenOwnerAccountA } = ataA, tokenOwnerAccountAIx = __rest(ataA, ["address"]);
            const { address: tokenOwnerAccountB } = ataB, tokenOwnerAccountBIx = __rest(ataB, ["address"]);
            txBuilder.addInstruction(tokenOwnerAccountAIx);
            txBuilder.addInstruction(tokenOwnerAccountBIx);
            const oraclePda = public_1.PDAUtil.getOracle(this.ctx.program.programId, this.address);
            txBuilder.addInstruction((0, instructions_1.swapIx)(this.ctx.program, Object.assign(Object.assign({}, input), { whirlpool: this.address, tokenAuthority: wallet, tokenOwnerAccountA, tokenVaultA: whirlpool.tokenVaultA, tokenOwnerAccountB, tokenVaultB: whirlpool.tokenVaultB, oracle: oraclePda.publicKey })));
            return txBuilder;
        });
    }
    refresh() {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.fetcher.getPool(this.address, true);
            if (!!account) {
                const rewardInfos = yield (0, util_1.getRewardInfos)(this.fetcher, account, true);
                const [tokenVaultAInfo, tokenVaultBInfo] = yield (0, util_1.getTokenVaultAccountInfos)(this.fetcher, account, true);
                this.data = account;
                this.tokenVaultAInfo = tokenVaultAInfo;
                this.tokenVaultBInfo = tokenVaultBInfo;
                this.rewardInfos = rewardInfos;
            }
        });
    }
}
exports.WhirlpoolImpl = WhirlpoolImpl;
